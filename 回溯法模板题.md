æ€»çš„æ¥è¯´ï¼Œæœ‰ä¸¤å¥—æ¨¡æ¿ï¼Œä¸¤å¥—æ¨¡æ¿çš„ä½¿ç”¨æ—¶æœºæ˜¯ä¸ä¸€æ ·çš„
**æ¨¡æ¿ä¸€ï¼ˆæœ‰forå¾ªç¯ï¼‰ï¼šä½¿ç”¨æ¡ä»¶æ˜¯ï¼Œæ‰€æœ‰çš„å…ƒç´ ä¸€å®šéƒ½å‡ºç°åœ¨ç»“æœé›†é‡Œé¢**
```java
public void dfs(String s, int i) {
    if (i == n) {
        ret.add(new ArrayList<String>(ans));
        return;
    }
    for (int j = i; j < n; ++j) {
        if (è¾¾åˆ°å‡ææ¡ä»¶) {
            continue;
        }
        ans++;
        dfs(s, j + 1);
        ans--;
    }
}
```
**æ¨¡äºŒï¼ˆæ— forå¾ªç¯ï¼‰ï¼šä½¿ç”¨æ¡ä»¶æ˜¯ï¼Œä¸ä¸€å®šæ‰€æœ‰çš„å…ƒç´ éƒ½å‡ºç°åœ¨ç»“æœé›†é‡Œé¢ï¼Œæœ‰çš„å…ƒç´ å¯ä»¥ä¸å‡ºç°åœ¨ç»“æœé›†åˆé‡Œé¢ï¼Œå³å­é›†é—®é¢˜**
```
void dfs(å½“å‰ä½ç½®, è·¯å¾„(å½“å‰ç»“æœ), ç»“æœé›†) {
    if (å½“å‰ä½ç½® == ç»“æŸä½ç½®) {
        ç»“æœé›†.add(è·¯å¾„);
        return;
    }
        
    é€‰æ‹©å½“å‰ä½ç½®;    
    dfs(ä¸‹ä¸€ä½ç½®, è·¯å¾„(å½“å‰ç»“æœ), ç»“æœé›†);
    æ’¤é”€é€‰æ‹©å½“å‰ä½ç½®;
    dfs(ä¸‹ä¸€ä½ç½®, è·¯å¾„(å½“å‰ç»“æœ), ç»“æœé›†);
}
```
# å­—ç¬¦ä¸²åˆ‡å‰²é—®é¢˜ï¼ˆæ¨¡æ¿ä¸€ï¼‰
ä¸ºä»€ä¹ˆè¦ç”¨forå¾ªç¯ï¼Œæˆ‘ä»¬æŠŠforå¾ªç¯æ‹†è§£å¼€æ¥å°±æ‡‚äº†
i = 0, æ­¤æ—¶tempResult = s(0, 0)ï¼Œdfs(1, n-1)æ˜¯é€’å½’å­ç»“æ„;
i = 1, æ­¤æ—¶tempResult = s(0, 1)ï¼Œdfs(2, n-1)æ˜¯é€’å½’å­ç»“æ„;
...
ç›´åˆ°i=n-1
ä¸¾ä¸ªğŸŒ° æ¥æ„Ÿå—ä¸‹æˆ‘ä»¬çš„çˆ†æœè¿‡ç¨‹ï¼Œå‡è®¾æœ‰æ ·ä¾‹ abababaï¼Œåˆšå¼€å§‹æˆ‘ä»¬ä»èµ·ç‚¹ç¬¬ä¸€ä¸ª a è¿›è¡Œçˆ†æœï¼š
å‘ç° a æ˜¯å›æ–‡ä¸²ï¼Œå…ˆå°† a åˆ†å‰²å‡ºæ¥ï¼Œå†å¯¹å‰©ä¸‹çš„ bababa è¿›è¡Œçˆ†æœ
å‘ç° aba æ˜¯å›æ–‡ä¸²ï¼Œå…ˆå°† aba åˆ†å‰²å‡ºæ¥ï¼Œå†å¯¹å‰©ä¸‹çš„ baba è¿›è¡Œçˆ†æœ
å‘ç° ababa æ˜¯å›æ–‡ä¸²ï¼Œå…ˆå°† ababa åˆ†å‰²å‡ºæ¥ï¼Œå†å¯¹å‰©ä¸‹çš„ ba è¿›è¡Œçˆ†æœ
å‘ç° abababa æ˜¯å›æ–‡ä¸²ï¼Œå…ˆå°† abababa åˆ†å‰²å‡ºæ¥ï¼Œå†å¯¹å‰©ä¸‹çš„ `` è¿›è¡Œçˆ†æœ
[131. åˆ†å‰²å›æ–‡ä¸²](https://leetcode-cn.com/problems/palindrome-partitioning/)
```java
class Solution {
    boolean[][] f;
    List<List<String>> ret = new ArrayList<List<String>>();
    List<String> ans = new ArrayList<String>();
    int n;

    public List<List<String>> partition(String s) {
        n = s.length();
        f = new boolean[n][n];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                f[i][j] = true;
            }
        }

        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                f[i][j] = (s.charAt(i) == s.charAt(j)) && f[i + 1][j - 1];
            }
        }

        dfs(s, 0);
        return ret;
    }

    public void dfs(String s, int i) {
        if (i == n) {
            ret.add(new ArrayList<String>(ans));
            return;
        }
        for (int j = i; j < n; ++j) {
            if (f[i][j]) {
                ans.add(s.substring(i, j + 1));
                dfs(s, j + 1);
                ans.remove(ans.size() - 1);
            }
        }
    }
}
```
[140. å•è¯æ‹†åˆ† II ](https://leetcode-cn.com/problems/word-break-ii/)
```java
class Solution {

    private List<String> wordDict;
    private List<String> ans;
    private Deque<String> temp;

    public List<String> wordBreak(String s, List<String> wordDict) {
        this.wordDict = wordDict;
        this.ans = new ArrayList<>();
        this.temp = new LinkedList<>();
        dfs(s);
        return ans;
    }

    public void dfs(String s) {
        if (s.length() == 0) {
            ans.add(String.join(" ", temp));
        }
        for (String word : wordDict) {
            if (s.startsWith(word)) {
                temp.add(word);
                dfs(s.substring(word.length()));
                temp.removeLast();
            }
        }
    }
}
```
[93. å¤åŸ IP åœ°å€](https://leetcode-cn.com/problems/restore-ip-addresses/)
```java
class Solution {
    // æœ€ç»ˆç»“æœ
    List<String> res = new ArrayList<>();
    // å½“å‰ç»“æœ
    Deque<String> curList = new LinkedList<>();

    public List<String> restoreIpAddresses(String s) {
        backTracking(s, 0);
        return res;
    }

    // indexè¡¨ç¤ºå­ä¸²çš„å¼€å§‹å­—ç¬¦çš„ä¸‹æ ‡
    public void backTracking(String s, int index) {
        if (curList.size() == 4) {
            String result = String.join(".", curList);
            if (result.length() == s.length() + 3) {
                res.add(result);
            }
            return;
        }
        // æ¯æ¬¡åˆ’åˆ†æ—¶ï¼Œå­ä¸²é•¿åº¦æœ€å¤šä¸º3ã€‚indexä¸ºå­ä¸²å¼€å§‹ä¸‹æ ‡ï¼Œiä¸ºå­ä¸²ç»“æŸä¸‹æ ‡
        for (int i = index + 1; i <= s.length() ; i++) {
            if (i - index > 4) {
                continue;
            }
            String sub = s.substring(index, i);
            if (!isValid(sub)) {
                continue;
            }
            curList.add(sub);
            // ä¸‹æ¬¡å†åˆ’åˆ†å­ä¸²å°±è¦ä»i+1ä½œä¸ºå­ä¸²çš„å¼€å§‹ä¸‹æ ‡
            // åˆ’åˆ†çš„æ¬¡æ•°+1
            backTracking(s, i);
            // å›æº¯ï¼Œåˆ’åˆ†ä¹‹å‰çš„é•¿åº¦æ˜¯lengthï¼ŒæŠŠé•¿åº¦æ¢å¤æˆlengthå°±å›æº¯å•¦
            curList.removeLast();
        }
    }

    // åˆ’åˆ†çš„å­ä¸²æ˜¯å¦æœ‰æ•ˆ
    public boolean isValid(String s) {
        char[] str = s.toCharArray();
        int n = str.length;
        // å¦‚æœå­ä¸²çš„é•¿åº¦å¤§äº1ï¼Œä½†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸ºâ€˜0â€™
        if ( n > 1 && str[0] == '0') {
            return false;
        }
        // å¦‚æœå­ä¸²çš„å€¼å¤§äº 255
        Long num = Long.valueOf(s);
        if (num > 255) {
            return false;
        }
        return true;
    }
}
```


# å­é›†é—®é¢˜
[78. å­é›†](https://leetcode-cn.com/problems/subsets/)
```java
class Solution {
    List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> subsets(int[] nums) {
        dfs(0, nums);
        return ans;
    }

    public void dfs(int cur, int[] nums) {
        if (cur == nums.length) {
            ans.add(new ArrayList<Integer>(t));
            return;
        }
        t.add(nums[cur]);
        dfs(cur + 1, nums);
        t.remove(t.size() - 1);
        dfs(cur + 1, nums);
    }
}
```
[90. å­é›† II](https://leetcode-cn.com/problems/subsets-ii/)
```java
class Solution {
    List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        dfs(false, 0, nums);
        return ans;
    }

    public void dfs(boolean choosePre, int cur, int[] nums) {
        if (cur == nums.length) {
            ans.add(new ArrayList<Integer>(t));
            return;
        }
        dfs(false, cur + 1, nums);
        if (!choosePre && cur > 0 && nums[cur - 1] == nums[cur]) {
            return;
        }
        t.add(nums[cur]);
        dfs(true, cur + 1, nums);
        t.remove(t.size() - 1);
    }
}
```
[301. åˆ é™¤æ— æ•ˆçš„æ‹¬å·](https://leetcode-cn.com/problems/remove-invalid-parentheses/)
```java
class Solution {
    Set<String> set = new HashSet<>();
    int n, max, len;
    String s;
    public List<String> removeInvalidParentheses(String _s) {
        s = _s;
        n = s.length();
        int l = 0, r = 0;
        for (char c : s.toCharArray()) {
            if (c == '(') l++;
            else if (c == ')') r++;
        }
        max = Math.min(l, r);
        dfs(0, "", 0);
        return new ArrayList<>(set);
    }
    void dfs(int u, String cur, int score) {
        if (score < 0 || score > max) return ;
        if (u == n) {
            if (score == 0 && cur.length() >= len) {
                if (cur.length() > len) set.clear();
                len = cur.length();
                set.add(cur);
            }
            return ;
        }
        char c = s.charAt(u);
        if (c == '(') {
            dfs(u + 1, cur + String.valueOf(c), score + 1);
            // åˆ é™¤'('
            dfs(u + 1, cur, score);
        } else if (c == ')') {
            dfs(u + 1, cur + String.valueOf(c), score - 1);
            // åˆ é™¤')'
            dfs(u + 1, cur, score);
        } else {
            dfs(u + 1, cur + String.valueOf(c), score);
        }
    }
}
```
[39. ç»„åˆæ€»å’Œ](https://leetcode-cn.com/problems/combination-sum/)
```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        List<Integer> combine = new ArrayList<Integer>();
        dfs(candidates, target, ans, combine, 0);
        return ans;
    }

    public void dfs(int[] candidates, int target, List<List<Integer>> ans, List<Integer> combine, int idx) {
        if (idx == candidates.length) {
            return;
        }
        if (target == 0) {
            ans.add(new ArrayList<Integer>(combine));
            return;
        }
        // ç›´æ¥è·³è¿‡
        dfs(candidates, target, ans, combine, idx + 1);
        // é€‰æ‹©å½“å‰æ•°
        if (target - candidates[idx] >= 0) {
            combine.add(candidates[idx]);
            dfs(candidates, target - candidates[idx], ans, combine, idx);
            combine.remove(combine.size() - 1);
        }
    }
}
```
[40. ç»„åˆæ€»å’Œ II](https://leetcode-cn.com/problems/combination-sum-ii/)
```java
class Solution {
    List<int[]> freq = new ArrayList<int[]>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();
    List<Integer> sequence = new ArrayList<Integer>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        for (int num : candidates) {
            int size = freq.size();
            if (freq.isEmpty() || num != freq.get(size - 1)[0]) {
                freq.add(new int[]{num, 1});
            } else {
                ++freq.get(size - 1)[1];
            }
        }
        dfs(0, target);
        return ans;
    }

    public void dfs(int pos, int rest) {
        if (rest == 0) {
            ans.add(new ArrayList<Integer>(sequence));
            return;
        }
        if (pos == freq.size() || rest < freq.get(pos)[0]) {
            return;
        }

        dfs(pos + 1, rest);

        int most = Math.min(rest / freq.get(pos)[0], freq.get(pos)[1]);
        for (int i = 1; i <= most; ++i) {
            sequence.add(freq.get(pos)[0]);
            dfs(pos + 1, rest - i * freq.get(pos)[0]);
        }
        for (int i = 1; i <= most; ++i) {
            sequence.remove(sequence.size() - 1);
        }
    }
}
```


# æ’åˆ—é—®é¢˜
[46. å…¨æ’åˆ—](https://leetcode-cn.com/problems/permutations/)
```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        int[] visited = new int[nums.length];
        backtrack(res, nums, new ArrayList<Integer>(), visited);
        return res;
    }

    private void backtrack(List<List<Integer>> res, int[] nums, ArrayList<Integer> tmp, int[] visited) {
        if (tmp.size() == nums.length) {
            res.add(new ArrayList<>(tmp));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (visited[i] == 1) continue;
            visited[i] = 1;
            tmp.add(nums[i]);
            backtrack(res, nums, tmp, visited);
            visited[i] = 0;
            tmp.remove(tmp.size() - 1);
        }
    }
}
```
[47. å…¨æ’åˆ— II](https://leetcode-cn.com/problems/permutations-ii/)
è¿™é¢˜çš„å…³é”®åœ¨äºå¦‚ä½•å‰ªæ
å‡è®¾è¾“å…¥ä¸º nums = [1,2,2']ï¼Œæ ‡å‡†çš„å…¨æ’åˆ—ç®—æ³•ä¼šå¾—å‡ºå¦‚ä¸‹ç­”æ¡ˆï¼š
```
[
    [1,2,2'],[1,2',2],
    [2,1,2'],[2,2',1],
    [2',1,2],[2',2,1]
]
```
å…¶ä¸­[1,2,2']ï¼Œ[1,2',2]é‡å¤äº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•æ’é™¤`[1,2',2]`è¿™ç§å¼‚å¸¸æƒ…å†µå‘¢ï¼Ÿ
æˆ‘ä»¬çš„ç›®çš„æ˜¯è¦åœ¨ç®—æ³•å³å°†è¦ç”Ÿæˆ`[1,2',2]`çš„æ—¶å€™åŠæ—¶å‘ç°å¹¶å°†å…¶æ’æ‰
æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ç”Ÿæˆçš„è¿‡ç¨‹ä¸­æ’å…¥ä¸€æ®µä»£ç æ¥åˆ¤æ–­å½“å‰çš„çŠ¶æ€
```java
if (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1]) {
    continue;
}
```
è¿™æ®µä»£ç æ„å‘³ç€ä¼šåœ¨å–ç›¸åŒæ•°çš„æ—¶å€™å§‹ç»ˆæŒ‰ç…§ä¸€å®šçš„é¡ºåºå–
å½“æˆ‘ä»¬åœ¨å–æœ€åä¸€ä¸ªæ•°2'æ—¶ï¼Œå‘ç°å®ƒå‰é¢ä¸€ä¸ªæ•°2è¿˜æ²¡è¢«è®¿é—®ï¼Œè¯´æ˜åœ¨ç”Ÿæˆçš„ç»“æœé‡Œé¢ï¼Œ2â€™ä¸€å®šæ’åœ¨2çš„å‰é¢ï¼Œæ˜¾ç„¶æ˜¯éæ³•çš„ï¼Œå› ä¸ºåœ¨ç»“æœé‡Œé¢ï¼Œ2ä¸€å®šè¦æ’åœ¨2'çš„å‰é¢ï¼Œå› æ­¤è¦å°†è¿™ç§æƒ…å†µæ’é™¤ã€‚
```java
class Solution {
    boolean[] vis;

    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        List<Integer> perm = new ArrayList<Integer>();
        vis = new boolean[nums.length];
        Arrays.sort(nums);
        backtrack(nums, ans, 0, perm);
        return ans;
    }

    public void backtrack(int[] nums, List<List<Integer>> ans, int idx, List<Integer> perm) {
        if (idx == nums.length) {
            ans.add(new ArrayList<Integer>(perm));
            return;
        }
        for (int i = 0; i < nums.length; ++i) {
            if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) {
                continue;
            }
            perm.add(nums[i]);
            vis[i] = true;
            backtrack(nums, ans, idx + 1, perm);
            vis[i] = false;
            perm.remove(idx);
        }
    }
}
```
[51. N çš‡å](https://leetcode-cn.com/problems/n-queens/)
è¿”å›æ‰€æœ‰å¯èƒ½çš„ç»“æœ
```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        // è®°å½•æ‰€æœ‰ç»“æœ
        List<List<String>> solutions = new ArrayList<List<String>>();
        int[] queens = new int[n];
        Arrays.fill(queens, -1);
        Set<Integer> columns = new HashSet<Integer>();
        Set<Integer> diagonals1 = new HashSet<Integer>();
        Set<Integer> diagonals2 = new HashSet<Integer>();
        backtrack(solutions, queens, n, 0, columns, diagonals1, diagonals2);
        return solutions;
    }

    public void backtrack(List<List<String>> solutions, int[] queens, int n, int row, Set<Integer> columns, Set<Integer> diagonals1, Set<Integer> diagonals2) {
        // è®°å½•å•æ¬¡ç»“æœ
        if (row == n) {
            List<String> board = generateBoard(queens, n);
            solutions.add(board);
            return;
        }
        for (int i = 0; i < n; i++) {
            // æ£€æŸ¥åˆ—
            if (columns.contains(i)) {
                continue;
            }
            // æ£€æŸ¥åå‘æ–œå¯¹è§’çº¿
            int diagonal1 = row - i;
            if (diagonals1.contains(diagonal1)) {
                continue;
            }
            // æ£€æŸ¥æ­£å‘æ–œå¯¹è§’çº¿
            int diagonal2 = row + i;
            if (diagonals2.contains(diagonal2)) {
                continue;
            }
            queens[row] = i;
            columns.add(i);
            diagonals1.add(diagonal1);
            diagonals2.add(diagonal2);
            backtrack(solutions, queens, n, row + 1, columns, diagonals1, diagonals2);
            queens[row] = -1;
            columns.remove(i);
            diagonals1.remove(diagonal1);
            diagonals2.remove(diagonal2);
        }
    }

    public List<String> generateBoard(int[] queens, int n) {
        List<String> board = new ArrayList<String>();
        for (int i = 0; i < n; i++) {
            char[] row = new char[n];
            Arrays.fill(row, '.');
            row[queens[i]] = 'Q';
            board.add(new String(row));
        }
        return board;
    }
}
```
[52. Nçš‡å II](https://leetcode-cn.com/problems/n-queens-ii/submissions/)
è¿”å›ç»“æœä¸ªæ•°
```java
class Solution {
    public int totalNQueens(int n) {
        Set<Integer> columns = new HashSet<Integer>();
        Set<Integer> diagonals1 = new HashSet<Integer>();
        Set<Integer> diagonals2 = new HashSet<Integer>();
        return backtrack(n, 0, columns, diagonals1, diagonals2);
    }

    public int backtrack(int n, int row, Set<Integer> columns, Set<Integer> diagonals1, Set<Integer> diagonals2) {
        if (row == n) {
            return 1;
        } else {
            int count = 0;
            for (int i = 0; i < n; i++) {
                if (columns.contains(i)) {
                    continue;
                }
                int diagonal1 = row - i;
                if (diagonals1.contains(diagonal1)) {
                    continue;
                }
                int diagonal2 = row + i;
                if (diagonals2.contains(diagonal2)) {
                    continue;
                }
                columns.add(i);
                diagonals1.add(diagonal1);
                diagonals2.add(diagonal2);
                count += backtrack(n, row + 1, columns, diagonals1, diagonals2);
                columns.remove(i);
                diagonals1.remove(diagonal1);
                diagonals2.remove(diagonal2);
            }
            return count;
        }
    }
}
```
[37. è§£æ•°ç‹¬](https://leetcode-cn.com/problems/sudoku-solver/)
```java
class Solution {
    // è®¿é—®æ•°ç»„ï¼Œè¡Œè®¿é—®
    private boolean[][] line = new boolean[9][9];
    // è®¿é—®æ•°ç»„ï¼Œåˆ—è®¿é—®
    private boolean[][] column = new boolean[9][9];
    // è®¿é—®æ•°ç»„ï¼Œå°æ–¹æ ¼è®¿é—®
    private boolean[][][] block = new boolean[3][3][9];
    private boolean valid = false;
    private List<int[]> spaces = new ArrayList<int[]>();

    public void solveSudoku(char[][] board) {
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                // å¦‚æœå½“å‰æ˜¯ç©ºæ ¼ï¼Œåˆ™è®°å½•ç©ºæ ¼ä¸‹æ ‡
                if (board[i][j] == '.') {
                    spaces.add(new int[]{i, j});
                } else {
                    // å¦‚æœå½“å‰æ˜¯æ•°å­—ï¼Œåˆ™åœ¨visitæ•°ç»„ä¸Šæ ‡è®°å·²è®¿é—®
                    int digit = board[i][j] - '0' - 1;
                    line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = true;
                }
            }
        }

        dfs(board, 0);
    }

    public void dfs(char[][] board, int pos) {
        if (pos == spaces.size()) {
            valid = true;
            return;
        }
        // æŒ‰è¡Œéå†ç©ºæ ¼
        int[] space = spaces.get(pos);
        int i = space[0], j = space[1];
        // å¯¹äºæ¯ä¸ªç©ºæ ¼ï¼Œå°è¯•9ä¸ªæ•°å­—
        for (int digit = 0; digit < 9 && !valid; ++digit) {
            if (!line[i][digit] && !column[j][digit] && !block[i / 3][j / 3][digit]) {
                line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = true;
                // å› ä¸ºdigitæ˜¯[0, 8]ï¼Œdigit+1åˆšå¥½æ˜¯[1, 9]
                board[i][j] = (char) (digit + '0' + 1);
                dfs(board, pos + 1);
                line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = false;
            }
        }
    }
}
```


**æœ‰å‘æ— ç¯å›¾çš„éå†**
[797. æ‰€æœ‰å¯èƒ½çš„è·¯å¾„](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    boolean[] visited;
    int n;
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        this.n = graph.length;
        LinkedList<Integer> list = new LinkedList<>();
        list.add(0);
        dfs(graph,0,list);
        return ans;
    }

    public void dfs(int[][] graph,int i,LinkedList<Integer> list){
        if(i == n - 1){
            ans.add(new ArrayList<>(list));
            return;
        }
        for(int j = 0;j < graph[i].length;j++){
            list.add(graph[i][j]);
            dfs(graph,graph[i][j],list);
            list.removeLast();
        }
    }
}
```
